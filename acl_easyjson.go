// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package  acl

import (
  easyjson "github.com/mailru/easyjson"
  jlexer "github.com/mailru/easyjson/jlexer"
  json "encoding/json"
  jwriter "github.com/mailru/easyjson/jwriter"
  time "time"
)

// suppress unused package warning
var (
   _ *json.RawMessage
   _ *jlexer.Lexer
   _ *jwriter.Writer
   _ easyjson.Marshaler
)

func easyjsonD215af56DecodeGithubComRaiProjectAcl(in *jlexer.Lexer, out *Limit) {
  isTopLevel := in.IsStart()
  if in.IsNull() {
    if isTopLevel {
      in.Consumed()
    }
    in.Skip()
    return
  }
  in.Delim('{')
  for !in.IsDelim('}') {
    key := in.UnsafeString()
    in.WantColon()
    if in.IsNull() {
       in.Skip()
       in.WantComma()
       continue
    }
    switch key {
    case "runtime":
      out.Runtime = time.Duration(in.Int64())
    case "storage":
      out.Storage = uint64(in.Uint64())
    case "mount_storage":
      out.MountStorage = uint64(in.Uint64())
    case "number_of_gpus":
      out.NumberOfGPUs = uint64(in.Uint64())
    case "cpu_architecture":
      out.CPUArchitecture = string(in.String())
    default:
      in.AddError(&jlexer.LexerError{
          Offset: in.GetPos(),
          Reason: "unknown field",
          Data: key,
      })
    }
    in.WantComma()
  }
  in.Delim('}')
  if isTopLevel {
    in.Consumed()
  }
}
func easyjsonD215af56EncodeGithubComRaiProjectAcl(out *jwriter.Writer, in Limit) {
  out.RawByte('{')
  first := true
  _ = first
  if in.Runtime != 0 {
    const prefix string = ",\"runtime\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.Int64(int64(in.Runtime))
  }
  if in.Storage != 0 {
    const prefix string = ",\"storage\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.Uint64(uint64(in.Storage))
  }
  if in.MountStorage != 0 {
    const prefix string = ",\"mount_storage\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.Uint64(uint64(in.MountStorage))
  }
  if in.NumberOfGPUs != 0 {
    const prefix string = ",\"number_of_gpus\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.Uint64(uint64(in.NumberOfGPUs))
  }
  if in.CPUArchitecture != "" {
    const prefix string = ",\"cpu_architecture\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.String(string(in.CPUArchitecture))
  }
  out.RawByte('}')
}
// MarshalJSON supports json.Marshaler interface
func (v Limit) MarshalJSON() ([]byte, error) {
  w := jwriter.Writer{}
  easyjsonD215af56EncodeGithubComRaiProjectAcl(&w, v)
  return w.Buffer.BuildBytes(), w.Error
}
// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Limit) MarshalEasyJSON(w *jwriter.Writer) {
  easyjsonD215af56EncodeGithubComRaiProjectAcl(w, v)
}
// UnmarshalJSON supports json.Unmarshaler interface
func (v *Limit) UnmarshalJSON(data []byte) error {
  r := jlexer.Lexer{Data: data}
  easyjsonD215af56DecodeGithubComRaiProjectAcl(&r, v)
  return r.Error()
}
// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Limit) UnmarshalEasyJSON(l *jlexer.Lexer) {
  easyjsonD215af56DecodeGithubComRaiProjectAcl(l, v)
}
func easyjsonD215af56DecodeGithubComRaiProjectAcl1(in *jlexer.Lexer, out *ACL) {
  isTopLevel := in.IsStart()
  if in.IsNull() {
    if isTopLevel {
      in.Consumed()
    }
    in.Skip()
    return
  }
  in.Delim('{')
  for !in.IsDelim('}') {
    key := in.UnsafeString()
    in.WantColon()
    if in.IsNull() {
       in.Skip()
       in.WantComma()
       continue
    }
    switch key {
    case "network_access":
      out.NetworkAccess = bool(in.Bool())
    case "mount_access":
      out.MountAccess = bool(in.Bool())
    case "queue_access":
      if in.IsNull() {
        in.Skip()
        out.QueueAccess = nil
      } else {
        in.Delim('[')
        if out.QueueAccess == nil {
          if !in.IsDelim(']') {
            out.QueueAccess = make([]string, 0, 4)
          } else {
            out.QueueAccess = []string{}
          }
        } else { 
          out.QueueAccess = (out.QueueAccess)[:0]
        }
        for !in.IsDelim(']') {
          var v1 string
          v1 = string(in.String())
          out.QueueAccess = append(out.QueueAccess, v1)
          in.WantComma()
        }
        in.Delim(']')
      }
    case "docker_push":
      out.DockerPush = bool(in.Bool())
    case "limit":
      (out.Limit).UnmarshalEasyJSON(in)
    default:
      in.AddError(&jlexer.LexerError{
          Offset: in.GetPos(),
          Reason: "unknown field",
          Data: key,
      })
    }
    in.WantComma()
  }
  in.Delim('}')
  if isTopLevel {
    in.Consumed()
  }
}
func easyjsonD215af56EncodeGithubComRaiProjectAcl1(out *jwriter.Writer, in ACL) {
  out.RawByte('{')
  first := true
  _ = first
  if in.NetworkAccess {
    const prefix string = ",\"network_access\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.Bool(bool(in.NetworkAccess))
  }
  if in.MountAccess {
    const prefix string = ",\"mount_access\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.Bool(bool(in.MountAccess))
  }
  if len(in.QueueAccess) != 0 {
    const prefix string = ",\"queue_access\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    {
      out.RawByte('[')
      for v2, v3 := range in.QueueAccess {
        if v2 > 0 {
          out.RawByte(',')
        }
        out.String(string(v3))
      }
      out.RawByte(']')
    }
  }
  if in.DockerPush {
    const prefix string = ",\"docker_push\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    out.Bool(bool(in.DockerPush))
  }
  if true {
    const prefix string = ",\"limit\":"
    if first {
      first = false
      out.RawString(prefix[1:])
    } else {
      out.RawString(prefix)
    }
    (in.Limit).MarshalEasyJSON(out)
  }
  out.RawByte('}')
}
// MarshalJSON supports json.Marshaler interface
func (v ACL) MarshalJSON() ([]byte, error) {
  w := jwriter.Writer{}
  easyjsonD215af56EncodeGithubComRaiProjectAcl1(&w, v)
  return w.Buffer.BuildBytes(), w.Error
}
// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ACL) MarshalEasyJSON(w *jwriter.Writer) {
  easyjsonD215af56EncodeGithubComRaiProjectAcl1(w, v)
}
// UnmarshalJSON supports json.Unmarshaler interface
func (v *ACL) UnmarshalJSON(data []byte) error {
  r := jlexer.Lexer{Data: data}
  easyjsonD215af56DecodeGithubComRaiProjectAcl1(&r, v)
  return r.Error()
}
// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ACL) UnmarshalEasyJSON(l *jlexer.Lexer) {
  easyjsonD215af56DecodeGithubComRaiProjectAcl1(l, v)
}
